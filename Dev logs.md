18/9
tools instalation & set up (wampserver)
git initialization
initial project structure: dummy pages, javascript classes, library inclusions, database set up, add user functionality with dummy data
antikatastasi dummy data me pragmatika dedomena poy pianontai apo form listener
skeftika to trade off anamesa ston diamoirasmo kai organwsi twn arxeiwn(pes to kalitera) kai sto pws den einai emfanes apo poy erxetai ka8e sinartisi
skeftika na valw webpack gia na ftianw mikra bundles gia tin ka8e omada apo scripts alla se auti ti fasi 8elw na elegsw ton kwdika opote isws ginei meta

meta skeftika pws otan sillega ta user creation data prepei ta form names na einai idia me ta object properties kai anarwti8ika an auto einai perioristiko
alla skeftika pws ta data einai sigkekrima kai den iparxei logos na allaksoun ta names sixna

teleiwsa to dev anarwtiomenos an 8a egrafa dika moy validation checks i an 8a xrisomopoiousa kapoio library san ton parsley.

20:00 -> 02:15 => 6:15 hours

19/9


αλλαγή σε κλάση και db για να φαίνεται καλύτερα η πληροφορία για τα βιβλία, redirection σε επιτυχή καταχώρηση χρήση.
Κοιτάω τη βάση και σκέφτομαι πως το index πρέπει να πάει στον πίνακα registry γιατί εκεί θα γίνονται τα πιο συχνά hits.
Τι μορφή θα έχει το query για τα δανεισμένα βιβλία; Φέρε μου book id όσον rows έχουν date loaned αλλά όχι date returned για τον συγκεκριμένο χρήστη;
Με τι θα κάνω αναζήτηση; Με user id και date returned, αφού με αυτά τα δύο μόνο μπορώ να βρω αν κάποιος έχει δανειστεί βιβλίο αλλά δεν το έχει επιστρέψει
(αν δεν έχει δανειστεί το id του δεν είναι εκεί, αν το έχει επιστρέψει μου φτάνει να κοιτάξω μόνο το returned date). Άρα index στο user id και το date returned.

add new book to db functionality

συνειδητοποίηα πως το ajax call θα μπορούσε να είναι επιτυχές αλλά το db operation να κάνει fail οπότε το διόρθωσα ελέγχοντας το επιστρεφόμενο μήνυμα.
στήσιμο του list users αλλά χάσιμο αρκετού χρόνου στο να βρω πώς να πακετάρω την απάντηση της βάσης σε json.
Katafera na to vrw meta apo ligo psaksimo alla paraolo poy ta epairna swsta, ta ellinika erxontan se unicode, wstoso emfanizontas ta sthn html itan pali utf8.
Sto telos stamatisa otan to ajax call epestrefe epitixws olous tous xristes.

10:30 -> 2:00 => 3.30 hours


20/9

Τελείωσα με το parsing των users σαν λίστα από objects και στη συνέχεια έφτιαξα το προσχέδιο για το πώς θα παρουσιάζονται.
Η λίστα θα φορτώνει onload και επειδή δεν μπορούμε να ξέρουμε πόσους θα έχουμε θα χρησιμοποιήσω δυναμική κατασκευή html στοιχείων
και για να είναι οργανωμένη θα χρησιμοποιήσω handlebars.js

άλλαξα την δομή του get users γιατί μου άρεσε περισσότερο να είναι το ajax call και το promise μαζί με το handlebars scripts
γιατί σε αντίθεση με τα add user/book, αυτό πρέπει να γίνει onload και μερικές φορές είναι δύσκολο να ακολουθήσεις την ροή των events όταν
πρέπει να μοιράσεις την προσοχή σου ανάμεσα σε ένα dom ready event και ένα script που εκτελείται κατευθείαν, επίσης δεν μου άρεσε
που η μεταβλητή users που έχει τα db objects αρχικοποιούνταν σε ένα αρχείο αλλά χρησιμοποιούνταν σε ένα άλλο (αυτό θα μπορούσε να λυθεί
με webpack και να έκανα require κάθε αρχείο όπου το χρειαζόμουν, αλλά δεν το έκανα γιατί αυτό θα απαιτούσε node.js και πακετάρισμα κάθε 
script σε module που κάνει export συγκεκριμένες συναρτήσεις. Θα το έκανα αν είχα περισσότερο χρόνο, αλλά επίσης ήθελα να παραδώσω κώδικα
που να έχει όσο το δυνατόν λιγότερο configuration χρειάζεται πριν τρέξει και ήδη απαιτούσε wampserver).

για το delete user functionality αναρωτήθηκα αν θα έπρεπε να ελέγχω τα βιβλία που έχει με ajax call στη βάση ή να βασιστώ στα δεδομένα που τράβηξα onload
δεδομένου πως το σύστημα είναι κεντρικό και αλλάζει μόνο από έναν χρήστη, επέλεξα τη δεύτερη επιλογή, αλλά αν το σύστημα 
ήταν να εγκατασταθεί σε πολλούς υπολογιστές τότε θα έκαναν τον έλεγχο ασύγχρονο με νέο query στη βάση για να ελέγχω σωστά αν τα δεδομένα έχουν αλλάξει
από τη στιγμή που έγιναν load στη σελίδα.

Επίσης αναλογίστηκα τι εξυπηρετεί να χειρίζομαι τα db objects σαν κλάση. Αρχικά ήθελα να τα μοντελοποιήσω σαν κλάσεις γιατί σκέφτηκα πως θα ήταν
ευκολότερος ο χειρισμός τους όταν θα προσθέτω / διαγράφω πράγματα στο dom, αλλά πρακτικά ήδη έχω πίνακα με db objects σαν JSON. Αν θέλω πριν καλέσω
την handlebars να φτιάξω ένα object πρακτικά θα είχα ένα db object που θα μετέτρεπα σε info object που θα το τάιζα στον class constructor και από το 
class object που θα μου επέστρεφε θα καλούσα την toJSON() για να μου δώσει ένα object με τα properties του class object το οποίο θα έδινα σαν όρισμα
στην handlebars template συνάρτηση. Αχρείαστα έξτρα βήματα, ειδικά από τη στιγμή που τα operations είναι τόσο απλά (άπαξ και κάνω render κάτι
ο μόνος τρόπος να το πειράξω είναι να το διαγράψω, εν προκειμένω η class απλά πακετάρει πληροφορία, κάτι που ήδη κάνω με τον τρόπο που κάνω query στη βάση
και που δίνω τα δεδομένα στην handlebars).

21:15 -> 12:00 => 2:45 hours

21/9

11:50

Σκοπός μου είναι να τελειώσω το manage user page βρίσκοντας και το ποια βιβλία έχει δανειστεί ο χρήστης. 
Θεωρητικά θα μπορούσα να κάνω το loan book to user functionality και μετά να επιστρέψω ξανά στην managa user page, αλλά αποφάσισα να στήσω
mock up data κάνοντας δύο manual εισαγωγές στη βάση δεδομένων για να έχω δεδομένα να συλλέξω όταν ένας χρήστης δεν μπορεί να διαγραφεί επειδη
χρωστάει βιβλία.

Για το format της ώρας σκέφτηκα πως θα μπορούσα να βάλω και timestamp, αλλά μία δανειστική βιβλιοθήκη δεν ενδιαφέρεται παρά μόνο για τις ημερομηνίες
και κατά πόσες μέρες έχεις ξεφύγει, οπότε η ώρα δεν θα είχε κάποιο νόημα.

Διαχώρισα το main.css αρχείο σε μικρότερα ανάλογα την σελίδα για να είναι τμηματοποιημένος ο κώδικας

φτιάχνοτας τη σελίδα για manage books σκέφτηκα πως θέλω να είναι μία συμπυκνωμένη λίστα με τις απαραίτητες πληροφορίες για το βιβλίο, δηλαδή
όνομα, ISBN και αν είναι διαθέσιμο ή όχι. Το πεδιό summary είναι σημαντικό, αλλά όχι για έναν admin χρήστη ο οποίος θέλει απλά να δανείζει
και να επιστρέφει βιβλία. Αν έκανα render το summary κάθε βιβλίου εξαρχής, το dom θα γέμιζε από τα πρώτα βιβλία, από την άλλη αν το έβαζα
να εμφανίζεται δυναμικά, θα πρόσθετα μία πληροφορία η οποία δεν έχει νόημα για τον admin χρήστη, αλλά για τον απλό χρήστη που θέλει να δανειστεί
το βιβλίο. Αν υπήρχαν ρόλοι ίσως θα άξιζε, αλλά όπως είναι τώρα δεν πιστεύω πως χρειάζεται.

Τελικά έβαλα και το summary.

Εκ των υστέρων καταλαβαίνω πως είναι λίγο περιοριστικό το db schema μου ακριβώς γιατί το Registry κρατά πλήρες ιστορικό. Έτσι αν αναζητήσω
βιβλίο θα βρω και όλες τις παλαιότερες καταχωρήσεις. Έχασα πολύ χρόνο προσπαθώντας να βρω ένα query που θα μου επέστρεφε και όλα τα βιβλία
και για όσα είναι δανεισμένα αυτή τη στιγμή ποιος τα έχει, αλλά δεν κατάφερα να βρω κάτι που θα να με ικανοποιούσε (κυρίως γιατί τα left joins που
σκεφτόμουν θα έκαναν κάπως πολύπλοκα τα πράγματα κατά τη διάρκεια του front end parsing της πληροφορίας σε συνδυασμό πως είχα καιρό να γράψω php
και δεν ήθελα να χάσω πολύ χρόνο στο να βρω πώς θα μπορούσα να φτιάξω ένα JSON το οποίο θα έπρεπε να συμπληρώσω loopάροντας μέσα από τα αποτελέσματα) 
Κατέληξα με την λύση ενός δεύτερου ajax call στη βάση για να βρω ακριβώς όσους έχουν δανεισμένα βιβλία και μετά να τους αντιστοιχήσω στην λίστα βιβλίων 
που έχω κάνει ήδη render.
Το γεγονός πως για μία σελίδα και μία ενοποιημένη διαισθητικά πληροφορία κάνω δύο calls είναι σίγουρα ένα αδύναμο σημείο του implementation 
το οποίο αν συνέχιζα το dev αυτής της εφαρμογής οπωσδήποτε θα διόρθωνα.

Συνέχισα με το loan book page γεμίζοντας στην αρχή τη λίστα με όλα τα βιβλία που έχουν διαθέσιμα αντίτυπα και ύστερα επιλέγοντας
όλους τους χρήστες που δεν έχουν ήδη δανειστεί 3. Στη συνέχεια κρατώ σε ένα javascript variable μία λίστα με όλα τα users id που έχουν δανεισμένο βιβλίο
αυτή τη στιγμή, έτσι ώστε ο έλεγχος να γίνεται client side και να μην χτυπάω τον server με τέτοια queries.

Η λογική είναι πως όταν πάει να γίνει ανάθεση, ο χρήστης σίγουρα δεν έχει 3 αντίτυπα, γιατί έχω φέρει μόνο όσους έχουν < 3 και αν έχει ήδη το αντίγραφο
θα το βρω στο front end. Αν δεν το έχει ήδη, τότε μπορώ να κάνω load το βιβλίο και να του το αναθέσω.

22/9

Μένει να τελειώσω τη loan book σελίδα και μετά να τη φτιάξω τη return book.

Εκ των υστέρων παρατηρώ πως κάποια php αρχεία πραγματοποιούν παρόμοια queries υπό το ίδιο http request. Σκέφτηκα πως θα μπορούσα
να τα ενοποιήσω, αλλά δεν ήθελα να γυρίσω πίσω σε δουλειά που είχε ήδη τελείωσει γιατί λόγω πίεσης χρόνου ήθελα να τελειώσω Κυριακή.
(Ίσως κάποιο γενικό php αρχείο που δέχεται γενικά ένα query αντί για ένα αρχείο ανά query).